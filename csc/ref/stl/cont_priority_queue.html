<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type"
    content="text/html; charset=iso-8859-1" />
    <title>The STL priority_queue Container Adaptor</title>
    <link rel="StyleSheet" href="../../../css/stdlib.css"
    type="text/css" />
  </head>
  <body>
    <p class="pageheader">C++ Reference Material
    <br />
     The STL priority_queue Container Adaptor</p>
    <p>The STL <tt>priority_queue</tt> is a <em>container adaptor</em>. That is, it
    is not a "first-class" container, but instead simply "adapts" one of
    the sequential first-class containers (by default, the <tt>vector</tt>)
    for its own purposes. So, the <tt>vector</tt> interface is restricted
    (i.e., much of it is hidden) so that the required access-via-highest-priority
    priority-queue-like behavior is provided.</p>
    <ul class="hardleft">
      <li><a href="#constructors">Constructors and destructor</a></li>
      <li><a href="#overloaded_ops">Overloaded operators</a></li>
      <li><a href="#access">Member function for accessing a value</a></li>
      <li><a href="#status">Member functions for reporting status</a></li>
      <li><a href="#insertion">Member function for inserting a
      value</a></li>
      <li><a href="#deletion">Member function for deleting a value</a></li>
      <li><a href="#misc_notes">Miscellaneous notes</a></li>
      <li><a href="#sample_programs">Sample programs</a></li>
      <li><a href="#prototypes">Member function prototypes</a></li>
    </ul>
    <h3><a id="constructors" name="constructors">Constructors and
    destructor</a></h3>
    <p>Default Constructor</p>
    <dl>
      <dt>priority_queue&lt;T&gt; pq;</dt>
      <dd>Construct an empty priority_queue <tt>pq</tt> which can hold
      values of type <tt>T</tt>.</dd>
    </dl>
    <hr />
    <p>Copy Constructor</p>
    <p>There is, of course, only one copy constructor, but there are two
    syntactic forms that invoke it, and both are shown.</p>
    <dl>
      <dt>priority_queue&lt;T&gt; pq(otherPriorityQueue);</dt>
      <dd>Construct <tt>pq</tt> as a copy of <tt>otherPriorityQueue</tt>,
      whose component type must be <tt>T</tt>.</dd>
      <dt>priority_queue&lt;T&gt; pq = otherPriorityQueue;</dt>
      <dd>Copy constructor (alternate usage syntax).</dd>
    </dl>
    <hr />
    <p>Destructor</p>
    <p>Any priority_queue will have a container data member (by default, a
    deque) which will hold its elements. That data member will have its own
    destructor which will automatically be invoked when the priority_queue
    goes out of scope.</p>
    <h3><a id="overloaded_ops" name="overloaded_ops">Overloaded
    operators</a></h3>
    <p>Assignment operator</p>
    <dl>
      <dt>pq1 = pq2</dt>
      <dd>Assign <tt>pq2</tt> to <tt>pq1</tt>, and return the common value.
      The priority_queue on the left of an assignment receives the values
      and size of the one on the right.</dd>
    </dl>
    <h3><a id="access" name="access">Member function for accessing a
    value</a></h3>
    <dl>
      <dt>pq.top()</dt>
      <dd>Return a <tt>reference</tt> (or <tt>const_reference</tt>) to the
      component of <tt>pq</tt> with the highest priority.</dd>
    </dl>
    <h3><a id="status" name="status">Member functions for reporting
    status</a></h3>
    <dl>
      <dt>pq.size()</dt>
      <dd>Return a value of type <tt>size_type</tt> giving the number of
      values currently in <tt>pq</tt>.</dd>
      <dt>pq.empty()</dt>
      <dd>Return <tt>true</tt> if <tt>pq</tt> is empty (contains zero
      values); otherwise return <tt>false</tt>.</dd>
    </dl>
    <h3><a id="insertion" name="insertion">Member function for inserting a
    value</a></h3>
    <dl>
      <dt>pq.push(val)</dt>
      <dd>Add <tt>val</tt> to <tt>pq</tt>, increasing the size of
      <tt>pq</tt> by one.</dd>
    </dl>
    <h3><a id="deletion" name="deletion">Member function for deleting a
    value</a></h3>
    <dl>
      <dt>pq.pop()</dt>
      <dd>Delete the value of <tt>pq</tt> with the highest priority,
      decreasing the size of <tt>pq</tt> by one.</dd>
    </dl>
    <h3 class="miscnotes"><a id="misc_notes"
    name="misc_notes">Miscellaneous notes</a></h3>
    <dl>
      <dt>Implementation</dt>
      <dd>Standard C++ does not say how the STL containers and algorithms
      must be implemented. It does, however, state certain constraints,
      such as complexity constraints, to which each implementation must
      adhere. Thus it is much better to base your programs on the STL's
      performance guarantees, rather than upon any assumption about how a
      particular feature, like the <tt>priority_queue</tt> class, may be
      implemented. The priority_quqeue container adaptor is based by
      default on the vector. A deque could also be used, since both the
      vector and the deque provide the <tt>push_back()</tt>,
      <tt>pop_back()</tt> and <tt>front()</tt> operations that are
      necessary to support the priority_queu interface. Of course the list
      provides these operations as well, but the additional requirement of
      random acces, whcih is necessary for sorting the values (and which is
      done by the STL heap algorithms), elminates the list as a possible
      underlying container.</dd>
    </dl>
    <h3 class="sampleprogs"><a id="sample_programs"
    name="sample_programs">Sample programs</a></h3>
    <p>All programs have been compiled and run successfully under Microsoft
    Visual Studio .NET 2005, unless otherwise noted.</p>
    <dl>
      <dt><a
      href="programs/priority_queue/priority_queue01.cpp2html">priority_queue01.cpp</a>
      | <a
      href="programs/priority_queue/priority_queue01.exe">Windows_executable</a>
      | <a
      href="programs/priority_queue/priority_queue01.txt">program_output
      (text)</a></dt>
      <dd>Illustrates a simple priority queue of integers, including a
      default constructor, a copy constructor, and the push(), pop(),
      top(), empty() and size() member functions of the STL priority_queue
      interface.</dd>
      <dt><a
      href="programs/priority_queue/priority_queue02.cpp2html">priority_queue02.cpp</a>
      | <a
      href="programs/priority_queue/priority_queue02.exe">Windows_executable</a>
      | <a
      href="programs/priority_queue/priority_queue02.txt">program_output
      (text)</a></dt>
      <dd>Illustrates two constructors of the STL priority-queue class, and
      the assignment of one priority_queue object to another.</dd>
      <dt><a
      href="programs/priority_queue/priority_queue03.cpp2html">priority_queue03.cpp</a>
      | <a
      href="programs/priority_queue/priority_queue03.exe">Windows_executable</a>
      | <a
      href="programs/priority_queue/priority_queue03.txt">program_output
      (text)</a></dt>
      <dd>Illustrates how to define a priority_queue object with the
      priority determined by a built-in "function object", and also how to
      alter the underlying container used by the priority_queue
      object.</dd>
      <dt><a
      href="programs/priority_queue/priority_queue04.cpp2html">priority_queue04.cpp</a>
      | <a
      href="programs/priority_queue/priority_queue04.exe">Windows_executable</a>
      | <a
      href="programs/priority_queue/priority_queue04.txt">program_output
      (text)</a></dt>
      <dd>Illustrates how <em>not</em> to access the components of a
      priority queue.</dd>
      <dt><a
      href="programs/priority_queue/priority_queue05.cpp2html">priority_queue05.cpp</a>
      | <a
      href="programs/priority_queue/priority_queue05.exe">Windows_executable</a>
      | <a
      href="programs/priority_queue/priority_queue05.txt">program_output
      (text)</a></dt>
      <dd>Illustrates a simple priority queue of class objects, in which
      the priority has been defined by overloading "operator&lt;".</dd>
      <dt><a
      href="programs/priority_queue/priority_queue06.cpp2html">priority_queue06.cpp</a>
      | <a
      href="programs/priority_queue/priority_queue06.exe">Windows_executable</a>
      | <a
      href="programs/priority_queue/priority_queue06.txt">program_output
      (text)</a></dt>
      <dd>Illustrates a simple priority queue of class objects, in which
      the priority has been defined by overloading "operator&gt;" and using
      this in conjuction with the built-in functor template class
      "greater&lt;&gt;".</dd>
    </dl>
    <h3 class="prototypes"><a id="prototypes" name="prototypes">Member
    function prototypes</a></h3>
    <p>Template specification for the priority_queue class</p>
<pre xml:space="preserve">
template&lt;class T,
         class Allocator = allocator&lt;T&gt; &gt;
class priority_queue { ... }
</pre>
    <hr />
    <p>Default Constructor</p>
<pre xml:space="preserve">
explicit priority_queue(const Container&amp; c = Container());
</pre>
    <hr />
    <p>Copy Constructor</p>
<pre xml:space="preserve">
priority_queue(const Container&amp; otherContainer);
</pre>
    <hr />
    <p>Destructor</p>
<pre xml:space="preserve">
~priority_queue();
</pre>
    <hr />
    <p>empty</p>
<pre xml:space="preserve">
bool empty() const;
</pre>
    <hr />
    <p>pop</p>
<pre xml:space="preserve">
void pop();
</pre>
    <hr />
    <p>push</p>
<pre xml:space="preserve">
void push(const T&amp; val);
</pre>
    <hr />
    <p>size</p>
<pre xml:space="preserve">
size_type size() const;
</pre>
    <hr />
    <p>top</p>
<pre xml:space="preserve">
      T&amp; top() const;
const T&amp; top() const;
</pre>
  </body>
</html>

<!-- Localized -->