<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>STL Sequential Container Member Function Summary</title>
    <link rel="StyleSheet" href="../../../css/stdlib.css"
    type="text/css" />
  </head>
  <body>
    <p class="pageheader">C++ Reference Material
    <br />
     STL Sequential Container Classes
    <br />
     Member Function Summary</p>
    <p>This page contains two tables. The first lists all member functions
    common to all three types of sequential container (vector,
    deque, list). The second table lists all member
    functions that appear in one or two of these three containers, but not
    in all three.</p>
    <h3>Member functions present in all sequential containers</h3>
    <table border="5" cellspacing="0" cellpadding="3" width="670"
    summary="Member functions common to all sequential containers">
      <tr>
        <th>constructors</th>
      </tr>
      <tr>
        <td><tt>ContainerType&lt;T&gt; c;</tt>
        <br />
         Constructs an empty container which can hold values of component type
        T.</td>
      </tr>
      <tr>
        <td><tt>ContainerType&lt;T&gt; c(num);</tt>
        <br />
         Constructs a container of size <tt>num</tt>, with each component
        initialized to the default value of component type <tt>T()</tt>.</td>
      </tr>
      <tr>
        <td><tt>ContainerType&lt;T&gt; c(num, val);</tt>
        <br />
         Constructs a container of size <tt>num</tt> with each component
        initialized to the value <tt>val</tt>, which must be of type
        <tt>T</tt>.</td>
      </tr>
      <tr>
        <td><tt>ContainerType&lt;T&gt; c(inIterBegin, inIterEnd);</tt>
        <br />
         Constructs a container with values from the
        range <tt>[inIterBegin,inIterEnd)</tt> in another container (which
        does not necessarily have to be of the same container type as
        <tt>c</tt>, as long as its component type is <tt>T</tt>).</td>
      </tr>
      <tr>
        <td><tt>ContainerType&lt;T&gt; c(otherLikeContainer);</tt>
        <br />
         <tt>ContainerType&lt;T&gt; c = otherLikeContainer;</tt>
        <br />
         Copy constructor, showing both syntactic forms.</td>
      </tr>
      <tr>
        <th>assignment operator</th>
      </tr>
      <tr>
        <td><tt>c1 = c2</tt>
        <br />
         Assign one container to another like container (vector to vector,
        deque to deque, list to list), and return the assigned container.</td>
      </tr>
      <tr>
        <th>comparison operators</th>
      </tr>
      <tr>
        <td><tt>c1 == c2</tt>
        <br />
         Return <tt>true</tt> if <tt>c1</tt> and <tt>c2</tt> are two like
        containers which have the same size and contain the same values in
        the same order, and otherwise return <tt>false</tt>.</td>
      </tr>
      <tr>
        <td><tt>c1 != c2</tt>
        <br />
         Return <tt>true</tt> if <tt>c1 == c2</tt> returns <tt>false</tt>,
        and otherwise return <tt>false</tt>.</td>
      </tr>
      <tr>
        <td><tt>c1 &lt; c2</tt>
        <br />
         Return <tt>true</tt> if <tt>c1</tt> and <tt>c2</tt> are two like
        containers and if, in the pairwise comparison of the values from
        <tt>c1</tt> and <tt>c2</tt>, in the first pair in which the two
        differ the component from <tt>c1</tt> is less than the component
        from <tt>c2</tt>; otherwise return <tt>false</tt>.</td>
      </tr>
      <tr>
        <td><tt>c1 &lt;= c2</tt>
        <br />
         Return <tt>true</tt> if either <tt>c1 &lt; c2</tt> or <tt>c1 ==
        c2</tt> is <tt>true</tt>, and otherwise return <tt>false</tt>.</td>
      </tr>
      <tr>
        <td><tt>c1 &gt; c2</tt>
        <br />
         Return <tt>true</tt> if <tt>c2 &lt; c1</tt> is <tt>true</tt>, and
        otherwise return <tt>false</tt>.</td>
      </tr>
      <tr>
        <td><tt>c1 &gt;= c2</tt>
        <br />
         Return <tt>true</tt> if either <tt>c1 &gt; c2</tt> or <tt>c1 ==
        c2</tt> is <tt>true</tt>, and otherwise return <tt>false</tt>.</td>
      </tr>
      <tr>
        <th>testing for empty</th>
      </tr>
      <tr>
        <td><tt>bool empty() const</tt>
        <br />
         Return <tt>true</tt> if container is empty, and otherwise return
        <tt>false</tt>.</td>
      </tr>
      <tr>
        <th>getting/setting container size</th>
      </tr>
      <tr>
        <td><tt>size_type size() const</tt>
        <br />
         Return number of components currently in container.</td>
      </tr>
      <tr>
        <td><tt>size_type max_size() const</tt>
        <br />
         Return maximum number of components a container of the given type
        can hold.</td>
      </tr>
      <tr>
        <td><tt>void resize(size_type num, T&amp; val = T())</tt>
        <br />
         Change the size of the container to the value specified by
        <tt>num</tt>. If the container must be lengthened (and only in this
        case), components with value <tt>val</tt> are added to the end. If
        the container is shortened, values are lost.</td>
      </tr>
      <tr>
        <th>getting iterator/reference access to container locations</th>
      </tr>
      <tr>
        <td><tt>iterator begin()</tt>
        <br />
         <tt>const_iterator begin() const</tt>
        <br />
         Return an <tt>iterator</tt> (or <tt>const_iterator</tt>) pointing
        to the first component of a container.</td>
      </tr>
      <tr>
        <td><tt>iterator end()</tt>
        <br />
         <tt>const_iterator end() const</tt>
        <br />
         Return an <tt>iterator</tt> (or <tt>const_iterator</tt>) pointing
        to one-past-the-last component of a container.</td>
      </tr>
      <tr>
        <td><tt>reverse_iterator rbegin()</tt>
        <br />
         <tt>const_reverse_iterator rbegin() const</tt>
        <br />
         Return a <tt>reverse_iterator</tt> (or
        <tt>const_reverse_iterator</tt>) pointing to the last component of
        a container.</td>
      </tr>
      <tr>
        <td><tt>reverse_iterator rend()</tt>
        <br />
         <tt>const_reverse_iterator rend() const</tt>
        <br />
         Return a <tt>reverse_iterator</tt> (or
        <tt>const_reverse_iterator</tt>) pointing to one-before-the-first
        component of a container.</td>
      </tr>
      <tr>
        <td><tt>reference front()
        <br />
         const_reference front() const</tt>
        <br />
         Return a <tt>reference</tt> (or <tt>const_refernce</tt>) to the
        first component in the container.</td>
      </tr>
      <tr>
        <td><tt>reference back()
        <br />
         const_reference back() const</tt>
        <br />
         Return a <tt>reference</tt> (or <tt>const_refernce</tt>) to the
        last component in the container.</td>
      </tr>
      <tr>
        <th>inserting one or more values</th>
      </tr>
      <tr>
        <td><tt>void push_back(const T&amp; val)</tt>
        <br />
         Add a component with value <tt>val</tt> to the end of the
        container.</td>
      </tr>
      <tr>
        <td><tt>iterator insert(iterator iter, const T&amp; val)</tt>
        <br />
         Insert a component with value <tt>val</tt> immediately before the
        component pointed to by <tt>iter</tt> and return an
        <tt>iterator</tt> pointing to the inserted component.</td>
      </tr>
      <tr>
        <td><tt>void insert(iterator iter, size_type num, const T&amp;
        val)</tt>
        <br />
         Insert <tt>num</tt> copies of <tt>val</tt> immediately before the
        component pointed to by <tt>iter</tt>.</td>
      </tr>
      <tr>
        <td><tt>template&lt;typename InIterator&gt;</tt>
        <br />
         <tt>void insert(iterator iter, InIterator inIterBegin, InIterator
        inIterEnd)</tt>
        <br />
         Insert, immediately before the component pointed to by
        <tt>iter</tt>, values from the range
        <tt>[inIterBegin,inIterEnd)</tt> in another (and possibly different
        kind of) container, but whose component type matches that of the
        receiving container.</td>
      </tr>
      <tr>
        <th>assigning values</th>
      </tr>
      <tr>
        <td><tt>template&lt;typename InputIterator&gt;</tt>
        <br />
         <tt>void assign(InIterator inIterBegin, InIterator inIterEnd)</tt>
        <br />
         Assign to the vector the sequence of values from the range
        <tt>[inIterBegin,inIterEnd)</tt>, overwriting all current components.</td>
      </tr>
      <tr>
        <td><tt>void assign(size_type num, const T&amp; val)</tt>
        <br />
         Assign to the vector <tt>num</tt> components having the value
        <tt>val</tt>, overwriting all current components.</td>
      </tr>
      <tr>
        <th>deleting one or more values</th>
      </tr>
      <tr>
        <td><tt>void pop_back()</tt>
        <br />
         Remove the last component in the container.</td>
      </tr>
      <tr>
        <td><tt>iterator erase(iterator iter)</tt>
        <br />
         Remove the component pointed to by <tt>iter</tt> and return an
        iterator pointing to the component after the one removed (or to
        one-past-the-last if the last component was the one removed).</td>
      </tr>
      <tr>
        <td><tt>iterator erase(iterator iterBegin, iterator iterEnd)</tt>
        <br />
         Remove those components in the range <tt>[iterBegin,iterEnd)</tt> and
        return an iterator pointing to the component after the last one
        removed (or to one-past-the-last, if the range removed included the
        last component).</td>
      </tr>
      <tr>
        <td><tt>void clear()</tt>
        <br />
         Remove all components from the container.</td>
      </tr>
      <tr>
        <th>miscellaneous operations</th>
      </tr>
      <tr>
        <td><tt>void swap(otherLikeContainer)</tt>
        <br />
         Exchange components in the invoking container with those in
        <tt>otherLikeContainer</tt> (vector with vector, deque with deque,
        list with list).</td>
      </tr>
      <tr>
        <td><tt>allocator_type get_allocator() const</tt>
        <br />
         Return the allocator of the container.</td>
      </tr>
    </table>
    <h3 class="pagebreak">Member functions present in some sequential
    containers
    <br />
     but not common to all</h3>
    <table border="5" cellspacing="0" cellpadding="3" width="670"
    summary="Member functions not common to all sequential containers">
      <tr>
        <th>vector-only member functions</th>
      </tr>
      <tr>
        <td><tt>void reserve(size_type num)</tt>
        <br />
         Set the capacity of a vector so that it is equal to at least
        <tt>num</tt>.</td>
      </tr>
      <tr>
        <td><tt>size_type capacity() const</tt>
        <br />
         Return the current capacity of a vector.</td>
      </tr>
      <tr>
        <th>list-only member functions</th>
      </tr>
      <tr>
        <td><tt>void merge(list&lt;T, Allocator&gt;&amp; otherList)</tt>
        <br />
         Merge the list contained in <tt>otherList</tt> with the invoking
        list and clear <tt>otherList</tt>. (Both lists are assumed to be
        ordered and the result is also ordered.)</td>
      </tr>
      <tr>
        <td><tt>template&lt;typename BinaryPred&gt;</tt>
        <br />
         <tt>void merge(list&lt;T, Allocator&gt;&amp; otherList, BinaryPred
        binPred)</tt>
        <br />
         Same as preceding <tt>merge()</tt>, except that in this version a
        comparitor (binary predicate) <tt>binPred</tt> is
        provided to determine when one component precedes another.</td>
      </tr>
      <tr>
        <td><tt>void remove(const T&amp; val)</tt>
        <br />
         Remove all components with value <tt>val</tt> from a list.</td>
      </tr>
      <tr>
        <td><tt>template&lt;typename UnaryPred&gt;
        <br />
         void remove_if(UnaryPred unPred)</tt>
        <br />
         Remove all components for which the unary predicate function
        <tt>unPred</tt> returns <tt>true</tt>.</td>
      </tr>
      <tr>
        <td><tt>void reverse()</tt>
        <br />
         Reverse the order of all components of a list.</td>
      </tr>
      <tr>
        <td><tt>void sort()</tt>
        <br />
         Sort the components of a list into ascending order.</td>
      </tr>
      <tr>
        <td><tt>template&lt;typename ComparisonFunc&gt;
        <br />
         void sort(BinaryPred binPred)</tt>
        <br />
         Sort the components of a list using the comparitor
        <tt>binPred</tt> to determine when one component
        precedes another.</td>
      </tr>
      <tr>
        <td><tt>void splice(iterator iter, list&lt;T, Allocator&gt;&amp;
        otherList)</tt>
        <br />
         Remove all components from <tt>otherList</tt> and insert them 
        just before location <tt>iter</tt>.</td>
      </tr>
      <tr>
        <td><tt>void splice(iterator iter, list&lt;T, Allocator&gt;&amp;
        otherList, iterator otherIter)</tt>
        <br />
         Remove component pointed to by <tt>otherIter</tt> from
        <tt>otherList</tt> and insert it just before location <tt>iter</tt>.</td>
      </tr>
      <tr>
        <td><tt>void splice(iterator iter, list&lt;T, Allocator&gt;&amp;
        otherList, iterator otherIterBegin, iterator otherIterEnd)</tt>
        <br />
         Remove components from range <tt>[otherIterBegin,otherIterEnd)</tt> in
        <tt>otherList</tt> and insert them just before location <tt>iter</tt>.</td>
      </tr>
      <tr>
        <td><tt>void unique()</tt>
        <br />
         Remove consecutive duplicate items.</td>
      </tr>
      <tr>
        <td><tt>template&lt;typename BinaryPred&gt;
        <br />
         void unique(BinaryPred binPred)</tt>
        <br />
         Same as preceding <tt>unique()</tt> but uses
        <tt>binPred</tt> to determine when two components are
        duplicates.</td>
      </tr>
      <tr>
        <th>vector-and-deque-only member functions</th>
      </tr>
      <tr>
        <td><tt>reference at(size_type index)
        <br />
         const_reference at(size_type index) const</tt>
        <br />
         Return a <tt>reference</tt> (or <tt>const_reference</tt>)
          to the component specified by
        <tt>index</tt>. (Throws an <tt>out_of_range</tt> exception if
        <tt>index</tt> is out of bounds.)</td>
      </tr>
      <tr>
        <td><tt>reference operator[](size_type index)
        <br />
         const_reference operator[](size_type index) const</tt>
        <br />
         Return a <tt>reference</tt> (or <tt>const_reference</tt>)
          to the component specified by
        <tt>index</tt>. (Does not throw an <tt>out_of_range</tt> exception if
        <tt>index</tt> is out of bounds.)</td>
      </tr>
      <tr>
        <th>deque-and-list-only member functions</th>
      </tr>
      <tr>
        <td><tt>void push_front(val)</tt>
        <br />
         Add an component with value <tt>val</tt> to the front of the
        container.</td>
      </tr>
      <tr>
        <td><tt>void pop_front()</tt>
        <br />
         Remove the first component from the container.</td>
      </tr>
    </table>
  </body>
</html>

<!-- Localized -->